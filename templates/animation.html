<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{ title }}</title>
    <!-- animation_type: 'default' or 'anchor_points' -->
    <meta name="animationType" content="{{ animation_type }}">
    <!-- background_image_url (optional): URL of the background image -->
    <meta name="imgUrl" content="{{ background_image_url }}">
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f5f7fa;
            margin: 0;
        }

        svg {
            overflow: visible;
            max-width: 100%;
            height: auto;
            border: 1px solid #eee; /* Optional: adds a border so you can see the SVG bounds */
        }

        #workflowPath {
            fill: none;
            stroke: #bbb;
            stroke-width: 3;
        }

        #movingNode {
            fill: #007acc;
        }

        .stepText {
            font-size: 14px;
            fill: #333;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .controls {
            margin-top: 20px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 0 10px;
        }
    </style>
</head>
<body>

<h1>{{ title }}</h1>

<svg width="100%" height="600">
    <!-- <image href="{{ background_image_url }}" width="100%" height="100%" /> -->

    <path id="workflowPath"
          d="{{ workflow_path }}"
          stroke="#ccc"
          stroke-width="2"
          fill="none"/>
    <circle id="movingNode" r="10" />
    {% for step in steps %}
        <text class="stepText" id="{{ step._id }}">{{ step.text }}</text>
    {% endfor %}
</svg>

<div class="controls">
    <button id="prevStep">Previous Step</button>
    <button id="nextStep">Next Step</button>
</div>

<script>
/**
 * Converts an SVG path string from GIMP into an array of anchor points
 * @param {string} pathString - The SVG path string (d attribute)
 * @returns {Array<{x: number, y: number}>} Array of anchor points
 */
function convertPathToAnchorPoints(pathString) {
    // Clean up the path string by removing 'd=' and quotes if present
    let path = pathString;
    if (path.startsWith('d=')) {
        path = path.substring(2);
    }
    path = path.replace(/["']/g, '').replace(/\n/g, ' ').trim();
  
    // Extract all coordinate pairs
    const coordMatches = [...path.matchAll(/(\d+(?:\.\d+)?),(\d+(?:\.\d+)?)/g)];

    // Extract unique points (GIMP repeats coordinates in its path format)
    const anchorPoints = [];
    const seen = new Set();
  
    for (const match of coordMatches) {
        // Parse x and y values
        const x = parseFloat(match[1]);
        const y = parseFloat(match[2]);

        // Create a key to track unique points
        const key = `${x},${y}`;

        // Only add if we haven't seen this point before
        if (!seen.has(key)) {
            anchorPoints.push({ x, y });
            seen.add(key);
        }
    }
  
    return anchorPoints;
}
</script>

<script>
    const fetchSignedUrl = (img_url) => {
        return fetch('/load_img?img_url=' + img_url, {method: 'GET'})
            .then(response => response.text())
            .then(text => {
                // First decode the Base64 response
                const decoded = atob(text);
                // Then parse it as JSON
                return JSON.parse(decoded);
            })
            .then(data => data.signedUrl);
    };
</script>

<script>
    const animationType = document.querySelector('meta[name="animationType"]').getAttribute('content');

    const imageUrl = document.querySelector('meta[name="imgUrl"]').getAttribute('content');

    // Move this code outside the window.onload function so it's available earlier
    const pathString = path.getAttribute('d');
    const anchorPoints = convertPathToAnchorPoints(pathString);
    const pathBounds = calculatePathBounds(anchorPoints);

    // Add some padding around the bounds
    const padding = 100; // Increased padding
    const viewBoxX = Math.max(0, pathBounds.minX - padding);
    const viewBoxY = Math.max(0, pathBounds.minY - padding);
    const viewBoxWidth = pathBounds.maxX - pathBounds.minX + (padding * 2);
    const viewBoxHeight = pathBounds.maxY - pathBounds.minY + (padding * 2);

    // Set the viewBox immediately
    const svg = document.querySelector('svg');
    svg.setAttribute('viewBox', `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`);

    if (imageUrl) {
        // prepend `image` with `href` to `svg` element
        const svg = document.querySelector('svg');
        const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        
        // Set explicit coordinates matching the viewBox
        image.setAttribute('x', viewBoxX);
        image.setAttribute('y', viewBoxY);
        image.setAttribute('width', viewBoxWidth);
        image.setAttribute('height', viewBoxHeight);

        // 'slice' to cover entire area
        image.setAttribute('preserveAspectRatio', 'xMidYMid slice');
        
        svg.insertBefore(image, svg.firstChild);

        // Then set the href when the URL is available
        fetchSignedUrl(imageUrl).then((signedUrl) => {
            console.log('signedUrl', signedUrl);
            image.setAttribute('href', signedUrl);
        }).catch(error => {
            console.error('Error fetching signed URL:', error);
        });
    }

    const path = document.getElementById('workflowPath');
    const node = document.getElementById('movingNode');
    const pathLength = path.getTotalLength();
    
    let currentStep = 0;
    const animationDuration = 1000; // duration in ms
    let animating = false;

    const texts = document.querySelectorAll('text');

    const steps = Array.from({ length: texts.length }, (_, i) => i / (texts.length - 1));

    function easeInOut(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }

    function updateTextVisibility(stepIndex) {
        texts.forEach((text, index) => {
            text.style.opacity = index === stepIndex ? 1 : 0;
        });
    }

    function positionTexts() {
        steps.forEach((progress, index) => {
            const point = path.getPointAtLength(progress * pathLength);
            texts[index].setAttribute('x', point.x + 15);
            texts[index].setAttribute('y', point.y);
        });
    }

    function animateToStep(targetStep) {
        if (animating) return;
        animating = true;

        const startProgress = steps[currentStep];
        const endProgress = steps[targetStep];
        const startTime = performance.now();

        function animate(time) {
            const elapsed = time - startTime;
            let progress = Math.min(elapsed / animationDuration, 1);
            progress = easeInOut(progress);

            const currentProgress = startProgress + (endProgress - startProgress) * progress;
            const point = path.getPointAtLength(currentProgress * pathLength);

            node.setAttribute('cx', point.x);
            node.setAttribute('cy', point.y);

            if (elapsed < animationDuration) {
                requestAnimationFrame(animate);
            } else {
                animating = false;
                currentStep = targetStep;
                updateTextVisibility(currentStep);
            }
        }

        requestAnimationFrame(animate);
    }
    

    function animateToAnchorPoint(targetStep) {
        if (animating) return;
        animating = true;

        const startPoint = anchorPoints[currentStep];
        const endPoint = anchorPoints[targetStep];
        const startTime = performance.now();

        function animate(time) {
            const elapsed = time - startTime;
            let progress = Math.min(elapsed / animationDuration, 1);
            progress = easeInOut(progress);

            const currentX = startPoint.x + (endPoint.x - startPoint.x) * progress;
            const currentY = startPoint.y + (endPoint.y - startPoint.y) * progress;

            node.setAttribute('cx', currentX);
            node.setAttribute('cy', currentY);

            if (elapsed < animationDuration) {
            requestAnimationFrame(animate);
            } else {
            animating = false;
            currentStep = targetStep;
            updateTextVisibility(currentStep);
            }
        }

        requestAnimationFrame(animate);
    }

    function positionAnchorTexts() {
        anchorPoints.forEach((pt, index) => {
            texts[index].setAttribute('x', pt.x + 15);
            texts[index].setAttribute('y', pt.y);
        });
    }


    document.getElementById('nextStep').addEventListener('click', () => {
        if (currentStep < steps.length - 1) {
            if (animationType === 'anchor_points') {
                animateToAnchorPoint(currentStep + 1);
            } else {
                animateToStep(currentStep + 1);
            }
        }
    });

    document.getElementById('prevStep').addEventListener('click', () => {
        if (currentStep > 0) {
            if (animationType === 'anchor_points') {
                animateToAnchorPoint(currentStep - 1);
            } else {
                animateToStep(currentStep - 1);
            }
        }
    });

    function calculatePathBounds(points) {
        if (!points || points.length === 0) {
            return { minX: 0, minY: 0, maxX: 1000, maxY: 1000 };
        }

        const bounds = {
            minX: Number.MAX_VALUE,
            minY: Number.MAX_VALUE,
            maxX: Number.MIN_VALUE,
            maxY: Number.MIN_VALUE
        };

        points.forEach(point => {
            bounds.minX = Math.min(bounds.minX, point.x);
            bounds.minY = Math.min(bounds.minY, point.y);
            bounds.maxX = Math.max(bounds.maxX, point.x);
            bounds.maxY = Math.max(bounds.maxY, point.y);
        });

        return bounds;
    }

    window.onload = () => {
        if (animationType === 'anchor_points') {
            positionAnchorTexts();
        } else {
            positionTexts();
        }
        
        // Set initial position
        if (animationType === 'anchor_points' && anchorPoints.length > 0) {
            node.setAttribute('cx', anchorPoints[currentStep].x);
            node.setAttribute('cy', anchorPoints[currentStep].y);
        } else {
            const point = path.getPointAtLength(steps[currentStep] * pathLength);
            node.setAttribute('cx', point.x);
            node.setAttribute('cy', point.y);
        }

        updateTextVisibility(currentStep);
    };
</script>

</body>
</html>
