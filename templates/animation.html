<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SVG Path Animation with Steps</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f5f7fa;
            margin: 0;
        }

        svg {
            overflow: visible;
        }

        #workflowPath {
            fill: none;
            stroke: #bbb;
            stroke-width: 3;
        }

        #movingNode {
            fill: #007acc;
        }

        .stepText {
            font-size: 14px;
            fill: #333;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .controls {
            margin-top: 20px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 0 10px;
        }
    </style>
</head>
<body>

<svg width="600" height="300">
    <path id="workflowPath"
          d="{{ workflow_path }}"
          stroke="#ccc"
          stroke-width="2"
          fill="none"/>
    <circle id="movingNode" r="10" />
    {% for step in steps %}
        <text class="stepText" id="{{ step._id }}">{{ step.text }}</text>
    {% endfor %}
</svg>

<div class="controls">
    <button id="prevStep">Previous Step</button>
    <button id="nextStep">Next Step</button>
</div>

<script>
    const path = document.getElementById('workflowPath');
    const node = document.getElementById('movingNode');
    const pathLength = path.getTotalLength();
    
    let currentStep = 0;
    const animationDuration = 1000; // duration in ms
    let animating = false;

    const texts = document.querySelectorAll('text');
    
    const steps = Array.from({ length: texts.length }, (_, i) => i / (texts.length - 1));

    function easeInOut(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }

    function updateTextVisibility(stepIndex) {
        texts.forEach((text, index) => {
            text.style.opacity = index === stepIndex ? 1 : 0;
        });
    }

    function positionTexts() {
        steps.forEach((progress, index) => {
            const point = path.getPointAtLength(progress * pathLength);
            texts[index].setAttribute('x', point.x + 15);
            texts[index].setAttribute('y', point.y);
        });
    }

    function animateToStep(targetStep) {
        if (animating) return;
        animating = true;

        const startProgress = steps[currentStep];
        const endProgress = steps[targetStep];
        const startTime = performance.now();

        function animate(time) {
            const elapsed = time - startTime;
            let progress = Math.min(elapsed / animationDuration, 1);
            progress = easeInOut(progress);

            const currentProgress = startProgress + (endProgress - startProgress) * progress;
            const point = path.getPointAtLength(currentProgress * pathLength);

            node.setAttribute('cx', point.x);
            node.setAttribute('cy', point.y);

            if (elapsed < animationDuration) {
                requestAnimationFrame(animate);
            } else {
                animating = false;
                currentStep = targetStep;
                updateTextVisibility(currentStep);
            }
        }

        requestAnimationFrame(animate);
    }

    document.getElementById('nextStep').addEventListener('click', () => {
        if (currentStep < steps.length - 1) {
            animateToStep(currentStep + 1);
        }
    });

    document.getElementById('prevStep').addEventListener('click', () => {
        if (currentStep > 0) {
            animateToStep(currentStep - 1);
        }
    });

    window.onload = () => {
        positionTexts();
        const point = path.getPointAtLength(steps[currentStep] * pathLength);
        node.setAttribute('cx', point.x);
        node.setAttribute('cy', point.y);
        updateTextVisibility(currentStep);
    };
</script>

</body>
</html>
